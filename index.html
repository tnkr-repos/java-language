<!-- 06_oops.md -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta content="viewport" value="width=device-width, initial-scale=1" />
        <title>Java Language</title>
    </head>
    <body>
        <h1 id="data-hiding">DATA HIDING</h1>
        <ul>
        <li>Outside person can&#39;t access our internal data directly</li>
        <li>Our internal data should not go out directly</li>
        <li>After authentication outside person can access our internal data</li>
        <li>For e.g. after providing proper username and password we are able to access our
        Gmail inbox information</li>
        <li>Even though we are valid customer of the bank we are able to access our
        account information, but not that of others&#39;</li>
        <li>By declaring data member as private we can achieve data hiding</li>
        </ul>
        <pre><code class="language-java">public class Account {
            private double balance;
            public double getBalance() {
                // authentication
                return balance;
            }
        }
        </code></pre>
        <ul>
        <li>The main advantage is security</li>
        <li>It is highly recommended to declare data member as <code>private</code></li>
        </ul>
        <h1 id="abstraction">ABSTRACTION</h1>
        <ul>
        <li>Hiding internal implementation and highlighting the set of services which we
        are offering</li>
        <li>For e.g. through bank ATM GUI Screen bank highlights the set of services which
        they are offer without broadcasting internal implementation</li>
        <li>The main advantages are security, modularity in internal system improves
        maintainability of application</li>
        <li>By using interfaces and abstract classes we can implement abstraction</li>
        </ul>
        <h1 id="encapsulation">ENCAPSULATION</h1>
        <ul>
        <li>The process of binding data and corresponding methods into a single unit</li>
        <li>If any component follows data hiding and abstraction then such type of
        component is encapsulated component (Encapsulation = Data Hiding + Abstraction)</li>
        <li>The main advantages of encapsulation are same as that of data hiding and
        abstraction</li>
        <li>The main disadvantage of encapsulation is increase in length of code and slows
        down execution speed</li>
        </ul>
        <h2 id="tightly-encapsulated-class">TIGHTLY ENCAPSULATED CLASS</h2>
        <ul>
        <li>Every data member of the class is declared as <code>private</code></li>
        <li>Irrespective of whether the class contains corresponding getter and setter
        methods, and whether these methods are declared as <code>public</code> or not</li>
        <li>If the parent class is not tightly encapsulated, then no child class can be
        tightly encapsulated</li>
        </ul>
        <pre><code class="language-java">class A {
            int x = 10;
        }
        class B extends A {
            private int y = 20;
        }
        class C extends B {
            private int z = 30;
        }
        </code></pre>
        <h1 id="is-a-relationship">IS-A RELATIONSHIP</h1>
        <ul>
        <li>It is also known as inheritance</li>
        <li>The main advantage of is-a relationship is code reusability</li>
        <li>By using <code>extends</code> we can implement is-a relationship</li>
        <li>Conclusions:<ul>
        <li>Whatever methods parent class has, are by default available to the child,
        and hence using child reference we can call both parent and child class
        methods</li>
        <li>Whatever methods child has are not by default available to the parent,
        and hence using parent reference we cannot call child class specific methods</li>
        <li>Parent reference can be used to hold child object but using that reference
        we can call parent specific methods</li>
        <li>Child reference cannot be used to hold parent object</li>
        </ul>
        </li>
        </ul>
        <pre><code class="language-java">class P {
            public void m1() {
                System.out.println(&quot;Parent&quot;);
            }
        }
        class C extends P {
            public void m2() {
                System.out.println(&quot;Child&quot;);
            }
        }
        class Test {
            public static void main(String[] args) {
                P p = new P();
                p.m1();
                p.m2();     // invalid - Cannot find symbol m2() in P

                C c = new C();
                c.m1();
                c.m2();

                P p1 = new C();
                p1.m1();
                p1.m2();    // invalid - Cannot find symbol m2() in P

                C c1 = new P();     // invalid - incompatible types
            }
        }
        </code></pre>
        <ul>
        <li>The most common methods which are applicable for any type of child should be
        defined in parent class</li>
        <li>The specific methods which are applicable for a particular child should be
        defined in the respective child class</li>
        </ul>
        <h2 id="java-api">JAVA API</h2>
        <ul>
        <li>For e.g. total Java API is implemented based on inheritance concept. The most
        common methods which are applicable for any Java object are defined in <code>Object</code>
        class and hence every class in Java is a child class of <code>Object</code> either directly
        or indirectly. So <code>Object</code> class methods are by default available to every Java
        class without rewriting. So <code>Object</code> class acts as root for all Java classes</li>
        <li><code>Throwable</code> class contains the most common methods which are required for
        every <code>Exception</code> and <code>Error</code> classes. So <code>Throwable</code> class acts as root for
        Java Exception Hierarchy</li>
        </ul>
        <pre><code>Object
        |---- String
        |---- StringBuffer
        |---- Throwable
        |---- |---- Exception
        |---- |---- |---- RuntimeException
        |---- |---- |---- |---- ArithmeticException
        |---- |---- |---- |---- NullPointerException
        |---- |---- |---- IOException
        |---- |---- Error
        |---- |---- |---- OutOfMemoryError
        </code></pre>
        <h2 id="multiple-inheritance">MULTIPLE INHERITANCE</h2>
        <ul>
        <li>A Java class can&#39;t extend more than 1 class at a time. Hence, Multiple
        inheritance is not supported in Java with respect to classes</li>
        <li>Note:<ul>
        <li>If our class doesn&#39;t extend any other class then only our class is direct
        child class of <code>Object</code></li>
        </ul>
        <pre><code class="language-java">class A {}  // Object &lt;- A
        </code></pre>
        <ul>
        <li>If our class extends any other class then our class is indirect child
        class of <code>Object</code> (using Multi-level inheritance)</li>
        </ul>
        <pre><code class="language-java">class B extends A {}    // Object &lt;- A &lt;- B and not Object, A &lt;- B
        </code></pre>
        </li>
        <li>This is because of Ambiguity problem (like Diamond Ambiguity)</li>
        </ul>
        <pre><code class="language-java">class P1 {
            public void m1();
        }
        class P2 {
            public void m1();
        }
        class A extends P1, P2 {
            // which m1() method should it inherit
        }
        </code></pre>
        <ul>
        <li>But interface can extend any number of interfaces simultaneously. Hence, Java
        provides support for Multiple inheritance with respect to interfaces</li>
        </ul>
        <pre><code class="language-java">interface A {}  // m1() declaration
        interface B {}  // m1() declaration
        interface C extends A, B {} // m1() declaration
        class T implements C {} // implementation for m1()
        </code></pre>
        <ul>
        <li>This is because ambiguity problem won&#39;t be possible in interfaces. Even
        though multiple method declarations will be available, but implementation will
        be unique (provided by the implementation class)</li>
        <li>Strictly speaking through interfaces we won&#39;t get any inheritance (this is
        because we don&#39;t have any implementation for the methods present in interfaces,
        so there is no use of reusability)</li>
        </ul>
        <h2 id="cyclic-inheritance">CYCLIC INHERITANCE</h2>
        <ul>
        <li>Not allowed in Java (since it is not required)</li>
        </ul>
        <h1 id="has-a-relationship">HAS-A RELATIONSHIP</h1>
        <ul>
        <li>Has-a relationship is also known as Composition/Aggregation</li>
        <li>There is no specific keyword to implement Has-a relation. Most of the time we
        are dependent on <code>new</code> keyword</li>
        <li>The main advantage of has-a relationship is reusability of code</li>
        <li>For eg.</li>
        </ul>
        <pre><code class="language-java">class Car {
            Engine e = new Engine();    // Car HAS-A Engine reference
        }
        class Engine {
            // Engine specific functionality
        }
        </code></pre>
        <h2 id="difference-between-composition-and-aggregation">DIFFERENCE BETWEEN COMPOSITION AND AGGREGATION</h2>
        <table>
        <thead>
        <tr>
        <th><strong>Composition</strong></th>
        <th><strong>Aggregation</strong></th>
        </tr>
        </thead>
        <tbody><tr>
        <td>Without existing container object if there is no chance of existing contained objects</td>
        <td>Without the existence of container object there will be a chance of existence of contained object</td>
        </tr>
        <tr>
        <td>For eg. University consists of several departments. Without existence of University, departments cannot exist either</td>
        <td>For eg. Department consists of several professors. Without a department, professor will still be present</td>
        </tr>
        <tr>
        <td>Strong association</td>
        <td>Weak association</td>
        </tr>
        <tr>
        <td>Container object holds directly contained objects</td>
        <td>Container objects holds just references of contained objects</td>
        </tr>
        </tbody></table>
        <h2 id="is-a-vs-has-a">IS-A VS HAS-A</h2>
        <table>
        <thead>
        <tr>
        <th><strong>IS-A</strong></th>
        <th><strong>HAS-A</strong></th>
        </tr>
        </thead>
        <tbody><tr>
        <td>Total functionality of a class is required</td>
        <td>Part of functionality of a class is required</td>
        </tr>
        <tr>
        <td>For eg. Person Class and Student class (Student class wants whole of Person class)</td>
        <td>For eg. Test class and Demo class (Only a small set of functionalities of Test are required in Demo)</td>
        </tr>
        </tbody></table>
        <h1 id="function-signature">FUNCTION SIGNATURE</h1>
        <ul>
        <li>In Java method signature consists of method&#39;s name followed by argument types</li>
        </ul>
        <pre><code class="language-java">public static int m1(int i, float f) {} // Signature - m1(int, float)
        </code></pre>
        <ul>
        <li>Compiler will use method signature to resolve method calls</li>
        <li>Within a class two methods with the same signature are not allowed</li>
        </ul>
        <h1 id="overloading">OVERLOADING</h1>
        <ul>
        <li>Two methods are said to be overloaded iff both methods have the same name but
        different argument types</li>
        <li>The main advantage of overloading is reduced code complexity</li>
        <li>In overloading method resolution is always taken care by compiler based on
        reference type. Hence, overloading is also considered as compile time
        polymorphism / static type polymorphism / early binding</li>
        </ul>
        <h2 id="automatic-promotion-in-overloading">AUTOMATIC PROMOTION IN OVERLOADING</h2>
        <ul>
        <li>While resolving overloaded method if exact match method is not available then
        we won&#39;t get any compile time error immediately. First it will promote argument
        to the next level and check whether matched method is available or not. If it is
        available then it will be considered; if not available then compiler promotes
        argument once again to the next level. This process will be continued until all
        possible promotions. Still if the matched method is not available then we will
        get compile time error. The following are all possible promotions in overloading</li>
        </ul>
        <pre><code>byte -&gt; short   -&gt; int -&gt; long -&gt; float -&gt; double
        char            -&gt;
        </code></pre>
        <pre><code class="language-java">class Test {
            public void m1(int i) {
                System.out.println(&quot;int-arg&quot;);
            }
            public void m1(float i) {
                System.out.println(&quot;float-rag&quot;);
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1(10);   // int-arg
            t.m1(10.5f);    // float-arg
            t.m1(&#39;a&#39;);  // int-arg
            t.m1(10L);  // float-arg
            t.m1(10.5); // invalid - cannot find symbol m1(double)
        }
        </code></pre>
        <h2 id="parent-vs-class-type-arguments-in-overloading">PARENT VS CLASS TYPE ARGUMENTS IN OVERLOADING</h2>
        <ul>
        <li>While resolving overloaded methods compiler will always give preference to
        child type argument when compared with parent type argument</li>
        </ul>
        <pre><code class="language-java">class Test {
            public void m1(String s) {
                System.out.println(&quot;String version&quot;);
            }
            public void m1(Object o) {
                System.out.println(&quot;Object version&quot;);
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1(new Object()); // object version
            t.m1(&quot;durga&quot;);      // string version
            t.m1(null);         // string version
        }
        </code></pre>
        <h2 id="different-class-type-arguments-at-the-same-level">DIFFERENT CLASS TYPE ARGUMENTS AT THE SAME LEVEL</h2>
        <ul>
        <li>While resolving overloaded methods if different class type arguments are at
        the same level, then compiler will throw an ambiguity error. For eg. <code>String</code>
        and <code>StringBuffer</code> class are at the same level (both are direct children of
        <code>Object</code> class)</li>
        </ul>
        <pre><code class="language-java">class Test {
            public void m1(String s) {
                System.out.println(&quot;String version&quot;);
            }
            public void m1(StringBuffer sb) {
                System.out.println(&quot;StringBuffer version&quot;);
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1(&quot;durga&quot;);  // string version
            t.m1(new StringBuffer(&quot;durga&quot;));    // StringBuffer version
            t.m1(null);     // invalid - reference to m1() is ambiguous
        }
        </code></pre>
        <h2 id="change-in-order-of-arguments">CHANGE IN ORDER OF ARGUMENTS</h2>
        <ul>
        <li></li>
        </ul>
        <pre><code class="language-java">class Test {
            public void m1(int i, float f) {
                System.out.println(&quot;int float version&quot;);
            }
            public void m1(float f, int i) {
                System.out.println(&quot;float int version&quot;);
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1(10, 10.5f);   // int float version
            t.m1(10.5f, 10);    // float int version
            t.m1(10, 10);  // invalid - ambiguity error
            t.m1(10.5f, 10.5f);  // invalid - cannot find reference to m1(float, float)
            t.m1(10.5); // invalid - cannot find symbol m1(double)
        }
        </code></pre>
        <h2 id="variable-argument-methods">VARIABLE ARGUMENT METHODS</h2>
        <ul>
        <li>Since variable argument type came in a later version, so to provide backwards
        compatibility Java will try and match single argument with the generic type
        method rather than the variable argument method</li>
        <li>In general, var-arg method will get the least priority. If no other method
        matches, only then the var-arg method will get the chance (similar to the
        <code>default</code> case inside <code>switch</code> block)</li>
        </ul>
        <pre><code class="language-java">class Test {
            public void m1(int i) {
                System.out.println(&quot;Generic method&quot;);
            }
            public void m1(int... i) {
                System.out.println(&quot;Var-arg method&quot;);
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.m1();     // var-arg method
            t.m1(10, 20);   // var-arg method
            t.m1(10);       // General method
        }
        </code></pre>
        <h2 id="reference-type-and-runtime-object">REFERENCE TYPE AND RUNTIME OBJECT</h2>
        <ul>
        <li>In overloading method resolution is always taken care by compiler based on
        reference type</li>
        <li>In overloading runtime object won&#39;t play any role</li>
        </ul>
        <pre><code class="language-java">class Animal {}
        class Monkey extends Animal {}
        class Test {
            public void m1(Animal a) {
                System.out.println(&quot;Animal version&quot;);
            }
            public void m1(Monkey m) {
                System.out.println(&quot;Monkey version&quot;);
            }
        }
        public static void main(String[] args) {
            Test t = new Test();
            Animal a = new Animal();
            t.m1(a);  // Animal version
            Monkey m = new Monkey();
            t.m1(m);  // Monkey version
            Animal a1 = new Monkey();
            t.m1(a1);  // Animal version
        }
        </code></pre>
        <h1 id="overriding">OVERRIDING</h1>
        <ul>
        <li>Whatever methods parent has are by default available to the child through
        inheritance. If child class is not satisfied with parent class implementation
        then child is allowed to redefine its method based on its requirement. This
        process is called overriding</li>
        <li>The parent class method which is overridden is called overridden method and the
        child class method which is overriding is called overriding method</li>
        </ul>
        <pre><code class="language-java">class P {
            public void property() {
                System.out.println(&quot;Cash + Land + Gold&quot;);
            }
            public void marry() {
                System.out.println(&quot;Subha Laxmi&quot;);
            }
        }
        class C extends P {
            public void marry() {
                System.out.println(&quot;Trisha&quot;);
            }
        }
        class Test {
            public static void main(String[] args) {
                P p = new P();
                p.marry();      // Subha Laxmi

                C c = new C();
                c.marry();      // Trisha

                P p1 = new P();
                p1.marry();     // Trisha
            }
        }
        </code></pre>
        <ul>
        <li>In overriding method resolution is always taken care by JVM based on runtime
        object, and hence overriding is also considered as runtime polymorphism / 
        dynamic polymorphism / late binding</li>
        </ul>
        <h2 id="rules-for-overriding">RULES FOR OVERRIDING</h2>
        <ul>
        <li>In overriding method names and argument types must match (method signatures
        must be same)</li>
        <li>In overriding return types must be same but this rule is applicable until 1.4v
        only. From 1.5v onwards we can take co-variant return types. According to this,
        child class method&#39;s return type need not be same as parent method return type,
        its child type is also allowed<ul>
        <li>Covariant return type concept is applicable only for object types but not
          for primitive types (<code>double</code> in parent class and <code>int</code> in child class, or
          similar won&#39;t work)</li>
        </ul>
        </li>
        </ul>
        <pre><code class="language-java">class P {
            public Object m1() {
                return null;
            }
        }
        class C extends P {
            public String m1() {
                return null;  // valid in &gt;= 1.5v; invalid &lt;= 1.4v
            }
        }
        </code></pre>
        <p>| <strong>Parent Class Method Return type</strong> 	| Object                            	| Number                      	|
        |-------------------------------------	|-----------------------------------	|-----------------------------	|
        | <strong>Child Class Method Return type</strong>  	| Object, String, StringBuffer, ... 	| Number, Integer, Float, ... 	|</p>
        <ul>
        <li>Parent class private methods are not available to the child and hence
        overriding concept is not applicable for private methods<ul>
        <li>Based on our requirement we can define exactly same private method in
          child class. It is valid, but this is not overriding</li>
        </ul>
        </li>
        </ul>
        <pre><code class="language-java">class P {
            private void m1() {}
        }
        class C extends P {
            private void m1() {}  // valid - not overriding
        }
        </code></pre>
        <ul>
        <li>We can&#39;t override parent class final methods in child classes. If we try to do
        so we will get compile time error. But we can override non-final parent methods
        as final in child class</li>
        </ul>
        <pre><code class="language-java">class P {
            public final void m1() {}
            public void m2() {}
        }
        class C extends P {
            public void m1() {}  // cannot override m1() in P it is final
            public final void m2() {}  // valid
        }
        </code></pre>
        <ul>
        <li>Parent class abstract methods we should override in child class to provide
        implementation</li>
        </ul>
        <pre><code class="language-java">abstract class P {
            public abstract void m1() {}
        }
        class C extends P {
            public void m1() {}
        }
        </code></pre>
        <ul>
        <li>We can override non-abstract methods as abstract. The main advantage of this
        approach is we can stop the availability of parent method implementation in the
        next child classes</li>
        </ul>
        <pre><code class="language-java">class P {
            public void m1() {}
        }
        abstract class C extends P {
            public abstract void m1() {}
        }
        </code></pre>
        <ul>
        <li><p>In overriding the following modifiers won&#39;t keep any restriction - strictfp,
        native, synchronized</p>
        </li>
        <li><p>While overriding we can&#39;t reduce scope of access modifier, but we can increase
        the scope</p>
        </li>
        </ul>
        <pre><code class="language-java">class P {
            public void m1() {}
            protected void m2() {}
        }
        class C extends P {
            void m1() {}  // m1() in C cannot override m1() in P - public to default
            public void m2() {} // valid - increasing scope from protected to public
        }
        </code></pre>
        <h3 id="overriding-and-exception-handling">OVERRIDING AND EXCEPTION HANDLING</h3>
        <ul>
        <li>Except <code>RuntimeException</code> and <code>Error</code> classes and their respective subclasses
        all others are checked exceptions. <code>RuntimeException</code> and <code>Error</code> classes and
        their respective subclasses are unchecked exceptions</li>
        <li>If child class method throws any checked exception, compulsory the parent
        class method should throw the same checked exception or its parent otherwise we
        will get compile time error. But there are no restrictions for unchecked
        exceptions</li>
        </ul>
        <pre><code class="language-java">// CASE 1
        class P {
            public void m1() throws Exception {} 
        }
        class C extends P {
            public void m1() {} // valid - no exception thrown by child class
        }

        // CASE 2
        class P {
            public void m1() {}
        }
        class C extends P {
            public void m1() throws Exception {}  // invalid - child throws checked
            // exception, but parent method does not throw it or its parent
        }

        // CASE 3
        class P {
            public void m1() throws Exception {}
        }
        class C extends P {
            public void m1() throws IOException {} // valid - child throws checked
            // exception, and parent method throws its parent exception
        }


        // CASE 4
        class P {
            public void m1() throws IOException {}
        }
        class C extends P {
            public void m1() throws Exception {} // invalid - child throws checked
            // exception but parent method doesn&#39;t throw the same or parent exception
        }


        // CASE 5
        class P {
            public void m1() throws IOException {}
        }
        class C extends P {
            public void m1() throws FileNotFoundException, EOFException {} // valid - 
            // child method throws checked exception and parent method throws parent
        }

        // CASE 6
        class P {
            public void m1() throws IOException {}
        }
        class C extends P {
            public void m1() throws EOFException, InterruptedException {} // invalid -
            // child throws checked exceptions and parent method throws parent exception
            // of only one of the checked exceptions
        }

        // CASE 7
        class P {
            public void m1() throws IOException {}
        }
        class C extends P {
            public void m1() throws ArithmeticException, NullPointerException {} // 
            // valid - child method does not throw any checked exception
        }
        </code></pre>
        <h2 id="overriding-with-respect-to-static-methods">OVERRIDING WITH RESPECT TO STATIC METHODS</h2>
        <ol>
        <li>We can&#39;t override a static method as non-static otherwise we will get compile
        time error</li>
        </ol>
        <pre><code class="language-java">class P {
            public static void m1() {}
        }
        class C extends P {
            public void m1() {} // invalid - m1() in C cannot override m1() in P
        }
        </code></pre>
        <ol start="2">
        <li>We can&#39;t override a non-static method as static</li>
        </ol>
        <pre><code class="language-java">class P {
            public void m1() {}
        }
        class C extends P {
            public static void m1() {} // invalid - m1() in C cannot override m1() in P
        }
        </code></pre>
        <ol start="3">
        <li>If both parent and child class methods are <code>static</code> then we won&#39;t get any
        compile time error. It seems overridding concept is applicable for static
        methods, but it is not overridding, rather it is method hiding</li>
        </ol>
        <pre><code class="language-java">class P {
            public static void m1() {}
        }
        class C extends P {
            public static void m1() {}
        }
        </code></pre>
        <h1 id="method-hiding">METHOD HIDING</h1>
        <ul>
        <li>All rules of method hiding are exactly same as overridding except the follwing
        differences:
        | <strong>Method Hiding</strong>                                                                    	| <strong>Overridding</strong>                                                                 	|
        |--------------------------------------------------------------------------------------	|---------------------------------------------------------------------------------	|
        | Both parent and child class methods should be static                                 	| Both parent and child class methods should be non-static                        	|
        | Compiler is responsible for method resolution based on reference type                	| JVM is responsible for method resolution based on runtime object                	|
        | Its is also known as compile-time polymorphism / static polymorphism / early binding 	| Its is also known as runtime polymorphism / dynamic polymorphism / late binding 	|</li>
        </ul>
        <pre><code class="language-java">class P {
            public static void m1() {
                System.out.println(&quot;Parent&quot;);
            }
        }
        class C extends P {
            public static void m1() {
                System.out.println(&quot;Child&quot;);
            }
        }
        class Test {
            public static void main(String[] args) {
                P p = new P();
                p.m1();  // Parent

                C c = new C();
                c.m1();  // Child

                P p1 = new C();
                p1.m1();  // Parent (would be Child if methods were non-static as
                // overridding concept would apply instead of method hiding)
            }
        }
        </code></pre>
        <ul>
        <li>If both parent and child class methods are non-static then it will become
        overridding. In this case output would be <code>Parent Child Child</code></li>
        </ul>
        <h2 id="overridding-with-respect-to-var-arg-methods">OVERRIDDING WITH RESPECT TO VAR ARG METHODS</h2>
        <p>- </p>
        <h1 id="coupling">COUPLING</h1>
        <ul>
        <li>The degree of dependency between the components is called coupling</li>
        <li>If dependency is more then it is considered as tightly coupling and if it is
        less then it is considered as loosely coupling</li>
        </ul>
        <pre><code class="language-java">// tight coupling
        class A {
            static int i = B.j;
        }
        class B {
            static int j = C.k;
        }
        class C {
            static int k = D.m1();
        }
        class D {
            public static int m1() {
                return 10;
            }
        }
        </code></pre>
        <ul>
        <li>The above components are said to be tightly coupled with each other because
        dependency between the components is more.</li>
        <li>Tightly coupling is not a good programming practice because it has several
        disadvantages:<ol>
        <li>Without affecting remaining components we can&#39;t modify any component</li>
        <li>Suppresses code reusability</li>
        <li>Reduces maintainability of the application</li>
        </ol>
        </li>
        <li>Hence, we have to maintain dependency between the components as less as
        possible. Loosely coupling is a good programming practice</li>
        </ul>
        <h1 id="cohesion">COHESION</h1>
        <ul>
        <li>For every component a clear well-defined functionality is defined then that
        component is said to follow high cohesion</li>
        <li><img src="./images/image.png" alt="Low vs High Cohesion"></li>
        <li>High cohesion is always a good programming practice because it has several
        advantages<ol>
        <li>Without affecting remaining components we can modify any component, thus
          easier enhancements</li>
        <li>Promotes code reusability (wherever validation is required we can use the
          same validateServlet without rewriting)</li>
        <li>It improves maintainibility of the application</li>
        </ol>
        </li>
        <li>Loosely coupling and high cohesion are good programming practices</li>
        </ul>
        <h1 id="object-type-casting">OBJECT TYPE CASTING</h1>
        <ul>
        <li>Parent reference can be used to hold child object (<code>Object o = new  String(&quot;durga&quot;)</code>)</li>
        <li>Interface reference can be used to hold implemented class object (<code>Runnable r = new Thread()</code>)</li>
        <li><code>A b = (C) d</code><ol>
        <li>A - class or interface name</li>
        <li>B - name of reference variable</li>
        <li>C - class or interface name</li>
        <li>D - Reference variable name</li>
        </ol>
        </li>
        </ul>
        <h2 id="compile-time-checking-i">COMPILE TIME CHECKING (I)</h2>
        <ul>
        <li>The type of <code>D</code> and <code>C</code> must have some relation either child-to-parent, or
        parent-to-child or same type, otherwise we will get compile time error saying
        inconvertible types</li>
        </ul>
        <pre><code class="language-java">Object o = new String(&quot;durga&quot;)
        StringBuffer sb = (StringBuffer)o;  // valid - StringBuffer and Object have
        // parent-to-child relation

        String s = new String(&quot;durga&quot;);
        StringBuffer sb = (StringBuffer)s;  // invalid - incovertible types
        </code></pre>
        <h2 id="compile-time-checking-ii">COMPILE TIME CHECKING (II)</h2>
        <ul>
        <li><code>C</code> must be either same or derived type of <code>A</code> otherwise we will get compile
        time error saying incompatible types</li>
        </ul>
        <pre><code class="language-java">Object o = new String(&quot;durga&quot;);
        StringBuffer sb = (StringBuffer)o;  // valid - StringBuffer and StringBuffer are
        // same

        Object o = new String(&quot;durga&quot;);
        StringBuffer sb = (String)o;  // invalid - incompatible types
        </code></pre>
        <h2 id="runtime-checking">RUNTIME CHECKING</h2>
        <ul>
        <li>Runtime object type of <code>d</code> must be either same or derived type of <code>C</code>
        otherwise we will get RuntimeException saying <code>ClassCastException</code></li>
        </ul>
        <pre><code class="language-java">Object o = new String(&quot;durga&quot;);
        StringBuffer sb = (StringBuffer)o; // invalid - ClassCastException
        // o has Runtime type of String(), and not Object()

        Object o = new String(&quot;durga&quot;);
        Object o1 = (String)o;  // valid - Runtime type of o is String() which is same
        // (String)
        </code></pre>
        <h2 id="conclusions">CONCLUSIONS</h2>
        <ol>
        <li>Strictly speaking through type casting we are not creating any new object. We
        are providing another type of reference variable for an existing object, i.e. we
        are performing type casting but not object casting</li>
        </ol>
        <pre><code class="language-java">String s = new String(&quot;durga&quot;);
        Object o = (Object)s;
        // New result - Object o = new String(&quot;durga&quot;)

        Integer i = new Integer(10);
        Number n = (Number)i;  // Number n = new Integer(10);
        Object o = (Object)n;  // Object o = new Integer(10);
        System.out.println(i == n);  // true
        System.out.println(n == o);  // true
        </code></pre>
        <ol start="2">
        <li>For e.g. A &lt;- B &lt;- C</li>
        </ol>
        <pre><code class="language-java">C c = new C();
        B b = new C();  // (B)c
        A a = new C();  // (A)((B)c)
        </code></pre>
        <ol start="3">
        <li>Parent reference can be used to hold child object but using that reference we
        can&#39;t call child specific methods, and we can call only the methods available in
        parent class</li>
        </ol>
        <pre><code class="language-java">C c = new C();
        c.m1();  // valid
        c.m2();  // valid
        ((P)c).m1();  // valid - P p = new C(); p.m1(); -&gt; Calling parent method from 
                    // parent reference
        ((P)c).m2();  // invalid - P p = new C(); p.m2(); -&gt; Calling child method from
                    // parent reference
        </code></pre>
        <h1 id="static-control-flow">STATIC CONTROL FLOW</h1>
        <ul>
        <li>Whenever we are executing a Java class the following sequence of steps will be
        executed as a part of static control flow<ol>
        <li>Identification of static members from top to bottom [1-6]</li>
        <li>Execution of static variable assignments and static blocks from top to
          bottom [7-12]</li>
        <li>Execution of <code>main</code> method [13-15]</li>
        </ol>
        </li>
        </ul>
        <pre><code class="language-java">class Base {
            static int i = 10;                           // 1 - static int i; 7 - i = 10
            static {                                     // 2 - static {}
                m1();                                    // 8
                System.out.println(&quot;First static block&quot;);// 10
            }
            public static void main(String[] args) {     // 3 - static main(String[])
                m1();                                    // 13
                System.out.println(&quot;Main method&quot;);       // 15
            }
            public static void m1() {                    // 4 - static m1()
                System.out.println(j);                   // 9, 14
            }
            static {                                     // 5 - static {}
                System.out.println(&quot;Second static block&quot;);// 11
            }
            static int j = 20;                          // 6 - static int j; 12 - j = 20
        }
        </code></pre>
        <h2 id="read-indirectly-write-only">READ INDIRECTLY WRITE ONLY</h2>
        <ul>
        <li>Inside a static block if we are trying to read a variable the read operation
        is called direct read</li>
        <li>If we are calling a method and within that method if we are trying to read a
        variable that read operation is called indirect read</li>
        </ul>
        <pre><code class="language-java">class Test {
            static int i = 10;
            static {
                m1();
                System.out.println(i);  // direct read
            }
            public static void m1() {
                System.out.println(i);  // indirect read
            }
        }
        </code></pre>
        <ul>
        <li>If a variable is just identified by JVM and original value is not yet assigned
        then the variable is said to be in read-indirectly-write-only state (RIWO)</li>
        <li>If a variable is in RIWO state then we can&#39;t perform direct read but we can
        perform indirect read</li>
        <li>If we are trying to read directly we will get compile time error saying
        &quot;Illegal forward reference&quot;</li>
        </ul>
        <h1 id="constructors">CONSTRUCTORS</h1>
        <ul>
        <li>Once we create an object compulsory we should perform initialisation then only
        the object is in a position to respond properly (since JVM will provide default
        values for instance variables)</li>
        <li>Its possible (but not recommended) to perform initialisation at the time of
        declaration of instance variables (initialisation inside a instance block also
        suffers from same issue)</li>
        </ul>
        <pre><code class="language-java">class Student {
            // these default values will initialise all objects with garbage values
            // hence not recommended
            String name = &quot;durga&quot;;
            int roll_no = 101;
        }
        </code></pre>
        <ul>
        <li>Whenever we are creating an object the constructor will be executed
        automatically to perform initialisation of the object. Hence the main purpose of
        constructor is initialisation of object and not creation of an object</li>
        </ul>
        <pre><code class="language-java">class Student {
            String name;
            int roll_no;
            Student(String name, int rollno) {
                this.name = name;
                this.rollno = rollno;
            }
            public static void main(String[] args) {
                Student s1 = new Student(&quot;durga&quot;, 101);
                Student s2 = new Student(&quot;Ravi&quot;, 102);
            }
        }
        </code></pre>
        <h2 id="difference-between-constructor-and-instance-block">DIFFERENCE BETWEEN CONSTRUCTOR AND INSTANCE BLOCK</h2>
        <ul>
        <li>Other than initialisation if we want to perform any activity for every object
        creation then we should go for instance block (like updating one entry in the
        database for every object creation or incrementing count value for every object
        creation)</li>
        <li>Both constructor and instance blocks have their own different purposes, and
        replacing one concept with another may not always work</li>
        <li>Both constructor and instance block will be executed for every object creation
        but instance block first followed by constructor</li>
        </ul>
        <pre><code class="language-java">// Print number of objects created for a class
        class Test {
            static int count = 0;
            {
                count++;
            }
            Test() {}
            Test(int i) {}
            Test(double d) {}
            public static void main(String[] args) {
                Test t1 = new Test();
                Test t2 = new Test(10);
                Test t3 = new Test(19.3);
                System.out.println(&quot;The number of objects created = &quot; + Test.count);
            }
        }
        </code></pre>
        <ul>
        <li>Putting <code>count++</code> inside each constructor can work, but its not recommended</li>
        </ul>
        <h2 id="rules-for-writing-constructor">RULES FOR WRITING CONSTRUCTOR</h2>
        <ul>
        <li>Name of the class and that of the constructor must be same</li>
        <li>Return type concept is not applicable for constructor even <code>void</code> also<ul>
        <li>By mistake if we are trying to declare return type for the constructor
          then we won&#39;t get any compile time error because compiler treats it like a
          method (this is legal but not recommended)</li>
        </ul>
        <pre><code class="language-java">class Test {
            void Test() {}  // It is method and not constructor
        }
        public static void main(String[] args) {
            Test t = new Test();
            t.Test();
        }
        </code></pre>
        </li>
        <li>The only applicable modifiers for constructors are <code>public</code>, <code>private</code>,
        <code>default</code> and <code>protected</code>. If we are trying to use any other modifier we will
        get compile time error</li>
        </ul>
        <pre><code class="language-java">class Test {
            static Test() {}  // modifier static not allowed here
        }
        </code></pre>
        <h2 id="default-constructor">DEFAULT CONSTRUCTOR</h2>
        <ul>
        <li>Compiler is responsible for generating default constructor (and not JVM)</li>
        <li>If we are not writing any constructor then only compiler will generate default
        constructor. Hence every class in Java contains constructor (either default
        constructor provided by compiler or customised constructor explicitly provided
        by programmer, but not both simultaneously)</li>
        </ul>
        <h3 id="prototype-of-default-constructor">PROTOTYPE OF DEFAULT CONSTRUCTOR</h3>
        <ul>
        <li>It is always a no-argument constructor</li>
        <li>The access modifier of default constructor is exactly same as access modifier
        of class. This rule is applicable for <code>public</code> and <code>default</code> (since we can&#39;t
        apply <code>private</code> and <code>protected</code> access modifiers for top level classes)</li>
        <li>It contains only 1 line -<code>super()</code> - It is a no argument call to Super class
        constructor</li>
        </ul>
        <h3 id="compiler-generated-code-for-default-constructors">COMPILER GENERATED CODE FOR DEFAULT CONSTRUCTORS</h3>
        <pre><code class="language-java">// CASE 1
        // programmer&#39;s code
        class Test {}
        // compiler&#39;s code
        class Test {
            Test() {  // default constructor created by compiler
                super();  // default constructor contains only 1 line of code - super()
            }
        }

        // CASE 2
        // programmer&#39;s code
        public class Test {}
        // compiler&#39;s code
        public class Test {
            public Test() { // default constructor has same access modifier as that of
                            // class
                super();  // default constructor contains only 1 line of code - super()
            }
        }

        // CASE 3
        // programmer&#39;s code
        public class Test {
            void Test() {}
        }
        // compiler&#39;s code
        public class Test {
            public Test() {
                super();
            }
            void Test() {}
        }
        </code></pre>
        <ul>
        <li>The first line inside our constructor should be either <code>super()</code> or <code>this()</code>,
        and if we are not writing anything then compiler will always place <code>super()</code></li>
        </ul>
        <pre><code class="language-java">// CASE 4
        // programmer&#39;s code
        class Test {
            Test() {}
        }
        // compiler&#39;s code
        class Test {
            Test() {
                super();
            }
        }

        // CASE 5
        // programmer&#39;s code
        class Test {
            Test(int i) {
                super();
            }
        }
        // compiler&#39;s code
        class Test {
            Test(int i) {
                super();
            }
        }

        // CASE 6
        // programmer&#39;s code
        class Test {
            Test() {
                this(10);
            }
            Test(int i) {}
        }
        // compiler&#39;s code
        class Test {
            Test() {
                this(10);
            }
            Test(int i) {
                super();
            }
        }
        </code></pre>
        <ul>
        <li>We can take <code>super()</code> or <code>this()</code> only in first line of constructor. If we
        trying to take anywhere else we will get compile time error</li>
        </ul>
        <pre><code class="language-java">class Test {
            Test() {
                System.out.println(&quot;Constructor&quot;);
                super();  // invalid - must be first statement in constructor
            }
        }
        </code></pre>
        <ul>
        <li>Within a constructor we can take either <code>super()</code> or <code>this()</code> but not both
        simulatenously</li>
        </ul>
        <pre><code class="language-java">class Test {
            Test() {
                super();
                this();  // invalid - must be first statement in constructor
            }
        }
        </code></pre>
        <ul>
        <li>We can use <code>super()</code> or <code>this()</code> only inside constructor. If we are trying to
        use outside of constructor we will get compile time error. This is because we
        can call a constructor directly from another constructor only</li>
        </ul>
        <pre><code class="language-java">class Test {
            public void m1() {
                super();  // invalid - must be first statement in constructor
                System.out.println(&quot;Hello&quot;);
            }
        }
        </code></pre>
        <ul>
        <li>Difference between <code>super()</code> and <code>this()</code> and <code>super</code> and <code>this</code>
        | <strong>super() and this()</strong>                                                         	| <strong>super and this</strong>                                                            	|
        |--------------------------------------------------------------------------------	|-------------------------------------------------------------------------------	|
        | These are constructor calls to call Super class and current class constructors 	| These are keywords to refer to Super class and current class instance members 	|
        | We can use only in constructors as first line                                  	| We can use anywhere except static area                                        	|
        | We can use only once in constructor                                            	| We can use any number of times                                                	|</li>
        </ul>
        <pre><code class="language-java">class P {
            int x = 100;
        }
        class C extends P {
            int x = 200;
            public void m1() {
                System.out.println(super.x);  // 100 - super.x = Parent class P.x
                System.out.println(this.x);  // 200 - this.x = Current class C.x
            }
            public static void main(String[] args) {
                System.out.println(super.hashCode());  // invalid - cannot reference
                // non-static super from a static area
            }
        }
        </code></pre>
        <h2 id="overloaded-constructors">OVERLOADED CONSTRUCTORS</h2>
        <ul>
        <li>Within a class we can declare multiple constructors and all these constructors
        having same name but different type of arguments. Hence all these constructors
        are considered as overloaded constructors. </li>
        <li>Hence overloading concept is applicable for constructors</li>
        </ul>
        <pre><code class="language-java">class Test {
            Test() {
                this(10);
                System.out.println(&quot;no-args&quot;);
            }
            Test(int i) {
                this(10.5);
                System.out.println(&quot;int-arg&quot;);
            }
            Test(double d) {
                System.out.println(&quot;double-arg&quot;);
            }
            public static void main(String[] args) {
                Test t1 = new Test();  // double-arg int-arg no-arg
                Test t2 = new Test(10); // double-arg int-arg
                Test t3 = new Test(10.5);  // double-arg
                Test t4 = new Test(10L);  // double-arg
            }
        }
        </code></pre>
        <ul>
        <li>For constructors inheritence and overridding concepts are not applicable</li>
        <li>Every class in Java including abstract class can contain constructors but
        interface cannot contain constructors. This is because a constructor is
        responsible for initialisation of an object (in further detail, its resposible
        for initialising instance members of a class). An interface can contain only
        static members and no instance variables</li>
        </ul>
        <h3 id="recursive-constructor-call">RECURSIVE CONSTRUCTOR CALL</h3>
        <ul>
        <li>Recursive method call is a runtime exception saying StackOverflowError. But in
        our program if there is a chance of recursive constructor invocation then the
        code won&#39;t compile and we will get compile time error</li>
        </ul>
        <pre><code class="language-java">class Test {
            public static void m1() {
                m2();
            }
            public static void m2() {
                m1();
            }
            public static void main(String[] args) {
                // if this line in commented then our code will compile and run fine
                m1();  // invalid - StackOverflowException due to filling of call stack
                System.out.println(&quot;Hello&quot;);
            }
        }

        class Pest {
            Pest() {
                this(10);
            }
            Pest(int i) {
                this();
            }
            public static void main(String[] args) {
                // compile time error
                System.out.println(&quot;Hello&quot;);  // invalid - recursive call to constructor
            }
        }
        </code></pre>
        <h3 id="constructors-and-inheritence">CONSTRUCTORS AND INHERITENCE</h3>
        <ul>
        <li>If parent class contains any argument constructors then while writing child
        classes we have to take special care with respect to constructors</li>
        <li>Whenever we are writing any argument constructor it is highly recommended to
        write no-argument constructor also</li>
        </ul>
        <pre><code class="language-java">// CASE 1
        // programmer&#39;s code
        class P {}
        class C extends P {}
        // compiler&#39;s code
        class P {
            P() {
                super();
            }
        }
        class C extends P {
            C() {
                super();  // calling no-arg constructor of parent class P() - valid
            }
        }

        // CASE 2
        // programmer&#39;s code
        class P {
            P() {}
        }
        class C extends P {}
        // compiler&#39;s code
        class P {
            P() {
                super();
            }
        }
        class C extends P {
            C() {
                super();  // calling no-arg constructor of parent class P() - valid
            }
        }

        // CASE 3
        // programmer&#39;s code
        class P {
            P(int i) {}
        }
        class C extends P {}  // invalid - cannot find P() in P
        // compiler&#39;s code
        class P {
            P(int i) {
                super();
            }
        }
        class C extends P {
            C() {
                super();  // calling no-arg constructor of parent class P() - none
                // hence invalid
            }
        }
        </code></pre>
        <h3 id="constructors-and-exception-handling">CONSTRUCTORS AND EXCEPTION HANDLING</h3>
        <ul>
        <li>For a checked exception, if a method <code>throws</code> a checked exception, it is the
        responsibility of the caller of that method to handle the checked exception.
        This handling can be done in two ways - using <code>try-catch</code>, or using <code>throws</code></li>
        </ul>
        <pre><code class="language-java">m1() throws IOException {}

        // valid caller - handles checked exception throws by called method using try
        // catch
        m2() {
            try {
                m1();
            } catch IOException {}
        }

        // valid caller - handles checked exception thrown by called method using throws
        m3() throws IOException {
            m1();
        }
        </code></pre>
        <ul>
        <li>If parent class constructors throws any checked exception compulsory child
        class constructor should throw the same checked exception or its parent,
        otherwise the code won&#39;t compile</li>
        </ul>
        <pre><code class="language-java">// programmer&#39;s code
        class P {
            P() throws IOException {}
        }
        class C extends P {}
        // compiler&#39;s code
        class P {
            P() throws IOException {
                super();
            }
        }
        class C extends P {
            C() {
                super();  // this is the caller to the no-arg parent class constructor
                // the caller should be responsible for handling the checked exception
                // since it does not hence this program gives compile time error
                // invalid - unreported exception IOException
            }
        }

        // SOLUTION TO THE PARENT THROWING A CHECKED EXCEPTION
        // Using try catch won&#39;t work because
        class P {
            P() throws IOException {}
        }
        class C extends P {
            C() {
                try {  // invalid - first line of constructor should be super() or
                       // this()
                    super();
                }
                catch IOException {}
            }
        }

        // Using throws is the only option
        // programmer&#39;s code
        class P {
            P() throws IOException {}
        }
        class C extends P {
            C() throws IOException {} // Exception | Throwable also work as they are
                                      // parent classes of IOException
        }
        // compiler&#39;s code
        class P {
            P() throws IOException {
                super();
            }
        }
        class C extends P {
            C() throws IOException {
                super();  // valid - calling no-arg constructor of parent class P()
                          // and handling the checked exception using throws
            }
        }
        </code></pre>
        <h2 id="summary-of-constructor">SUMMARY OF CONSTRUCTOR</h2>
        <ul>
        <li>The main purpose of constructor is to create an object - invalid</li>
        <li>The main purpose of constructor is to perform initialisation of an object - 
        valid</li>
        <li>The name of the constructor need not be same as the class name - invalid</li>
        <li>Return type concept is applicable for constructors but only void - invalid</li>
        <li>We can apply any modifier for constructor - invalid</li>
        <li>Default constructor is constructed by JVM - invalid</li>
        <li>Compiler is responsible to generate default constructor - valid</li>
        <li>Compiler will always generate default constructor - invalid</li>
        <li>If we are not writing no-arg constructor then compiler will generate a 
        default constructor - invalid</li>
        <li>Every no-arg constructor is a default constructor - invalid</li>
        <li>Default constructor is always no-arg constructor - valid</li>
        <li>First line inside a constructor should be <code>super()</code> or <code>this()</code>. If we are not
        writing anything then compiler will generate <code>this()</code> - invalid</li>
        <li>For constructors both overloading and overridding concepts are applicable -
        invalid</li>
        <li>For constructors inheritence concept is applicable but not overridding -
        invalid</li>
        <li>Only concrete classes can contain constructor, but abstract classes cannot -
        invalid</li>
        <li>Interface can contain constructors - invalid</li>
        <li>Recursive constructor invocation is a runtime exception - invalid</li>
        <li>If parent class constructor throws some checked exception then compulsory
        child class constructor should throw the same checked exception or its child -
        invalid</li>
        </ul>
        <h1 id="singleton-class">SINGLETON CLASS</h1>
        <ul>
        <li>Any Java class for which we are allowed to create only one object. For eg.
        <code>Runtime</code></li>
        </ul>
        <h2 id="advantage">ADVANTAGE</h2>
        <ul>
        <li>If several people have same requirement then it is not recommended to create
        separate object for every requirement. We have to create only one object and we
        can reuse same object for every similar requirement so that performance and
        memory utilisation will be improved</li>
        <li>This is the main use of private constructor. This is because we want to
        restrict object creation, so we make the constructor of the class inaccessible.
        To create objects for singleton class we use factory method</li>
        </ul>
        <pre><code class="language-java">Runtime r1 = Runtime.getRuntime();
        Runtime r2 = Runtime.getRuntime();
        </code></pre>
        <h2 id="creation-of-singleton-classes">CREATION OF SINGLETON CLASSES</h2>
        <ol>
        <li>By using private constructor, private static variable and public factory
        method</li>
        </ol>
        <ul>
        <li>Runtime class is internally implemented using this approach.</li>
        </ul>
        <pre><code class="language-java">class Test {
            private static Test t = new Test();
            private Test() {}
            public static Test getTest() {
                return t;
            }
        }
        // any references created will refer to the one common static object present
        Test t1 = Test.getTest();
        Test t2 = Test.getTest();
        </code></pre>
        <ol start="2">
        <li>Using another approach by creating object in the factory method (whenever we
        get the request for object creation the first time)</li>
        </ol>
        <pre><code class="language-java">class Test {
            private static Test t = null;
            private Test() {}
            public static Test getTest() {
                if (t == null) {
                    t = new Test();
                }
                return t;
            }
        }
        // the object gets created when t1 calls the factory method (and not before it)
        Test t1 = Test.getTest();
        // t2 refers to the same object being pointed to by t1
        Test t2 = Test.getTest();
        </code></pre>
        <h1 id="extras">EXTRAS</h1>
        <ul>
        <li>Class is not final but we are not allowed to create child classes. How is this
        possible?</li>
        <li>By declaring every constructor as private we can restrict child class creation</li>
        </ul>
        <pre><code class="language-java">class P {
            private P() {}
        }
        // for this class if we try to create a child class
        class C extends P {
            C() {}
            // the constructor of child class will have super() - which refers to
            // no-argument constructor of the parent class - which is inaccessible
            // since it is private
        }
        </code></pre>
    </body>
</html>